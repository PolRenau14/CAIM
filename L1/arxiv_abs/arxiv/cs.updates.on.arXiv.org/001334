The Windows Scheduling Problem, also known as the Pinwheel Problem, is to schedule periodic jobs
subject to their processing frequency demands. Instances are given as a set of jobs that have to be
processed infinitely often such that the time interval between two consecutive executions of the
same job j is no longer than the job's given period $p_j$. The key contribution of this work is a new
interpretation of the problem variant with exact periods, where the time interval between consecutive
executions must be strictly $p_j$. We show that this version is equivalent to a natural combinatorial
problem we call Partial Coding. Reductions in both directions can be realized in polynomial time,
so that both hardness proofs and algorithms for Partial Coding transfer to Windows Scheduling.
Applying this new perspective, we obtain a number of new results regarding the computational complexity
of various Windows Scheduling Problem variants. We prove that even the case of one processor and
unit-length jobs does not admit a pseudo-polynomial time algorithm unless SAT can be solved by a
randomized method in expected quasi-polynomial time. This result also extends to the case of inexact
periods, which answers a question that has remained open for more than two decades. Furthermore,
we report an error found in a hardness proof previously given for the multi-machine case without
machine migration, and we show that this variant reduces to the single-machine case. Finally, we
prove that even with unit-length jobs the problem is co-NP-hard when jobs are allowed to migrate
between machines. 